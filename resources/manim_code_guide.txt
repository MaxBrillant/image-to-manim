# Manim Community Edition Code Guide

This guide provides a comprehensive reference for Manim Community Edition, a mathematical animation engine for creating precise programmatic animations. It is designed to serve as a reference for generating Manim code, with a focus on clear patterns, examples, and best practices.

## Table of Contents

1. [Introduction and Basic Structure](#1-introduction-and-basic-structure)
2. [Core Concepts](#2-core-concepts)
3. [Basic Shapes and Transformations](#3-basic-shapes-and-transformations)
4. [Text and Mathematical Expressions](#4-text-and-mathematical-expressions)
5. [Graphing and Coordinate Systems](#5-graphing-and-coordinate-systems)
6. [Advanced Animation Techniques](#6-advanced-animation-techniques)
7. [3D Visualizations](#7-3d-visualizations)
8. [Special Effects and Techniques](#8-special-effects-and-techniques)
9. [Best Practices and Optimization](#9-best-practices-and-optimization)
10. [Common Examples and Templates](#10-common-examples-and-templates)
11. [Reference Tables](#11-reference-tables)

## 1. Introduction and Basic Structure

### Overview of Manim

Manim is a Python library for creating mathematical animations. It was originally created by Grant Sanderson (3Blue1Brown) and has been further developed by the Manim Community. The library is designed to create precise, programmatic animations for explaining mathematical concepts.

### Basic Structure of a Manim Script

Every Manim script follows a similar structure:

```python
from manim import *

class MyAnimation(Scene):
    def construct(self):
        # Create objects
        circle = Circle()

        # Customize objects
        circle.set_fill(BLUE, opacity=0.5)

        # Display animations
        self.play(Create(circle))
        self.wait(1)
```

#### Key Components:

1. **Import Statement**: Import all classes and functions from Manim
2. **Scene Class**: Define a class that inherits from `Scene` (or other scene types)
3. **Construct Method**: Define the `construct()` method where all animation logic goes
4. **Creating Objects**: Create mathematical objects (mobjects)
5. **Customizing Objects**: Modify properties of the objects
6. **Displaying Animations**: Use `self.play()` to animate objects and `self.wait()` to pause

### Running Manim Scripts

Manim scripts are run from the command line with various options:

```bash
manim -pql file_name.py ClassName
```

Common command-line arguments:

- `-p`: Preview the animation once it's rendered
- `-l`: Use low quality (faster rendering)
- `-m`: Use medium quality
- `-h`: Use high quality (slower rendering)
- `-q`: Quiet mode (less output)
- `-s`: Skip to the end and show the last frame
- `-k`: Keep the animation playing in a loop

## 2. Core Concepts

### Mobjects (Mathematical Objects)

Mobjects are the fundamental building blocks in Manim. Everything that appears on screen is a mobject.

#### Common Properties of Mobjects:

- **Position**: Coordinates in 3D space (though usually only x and y are used)
- **Color**: Fill and stroke colors
- **Opacity**: Fill and stroke opacity
- **Size**: Width, height, and depth
- **Stroke width**: Width of the outline

#### Common Mobject Methods:

```python
# Creation and basic properties
circle = Circle(radius=1.0)
square = Square(side_length=2.0)

# Positioning
circle.move_to([1, 2, 0])  # Move to absolute position
square.next_to(circle, RIGHT)  # Position relative to another mobject
square.shift(UP)  # Move relative to current position
circle.to_edge(LEFT)  # Move to the edge of the screen
square.to_corner(UR)  # Move to a corner of the screen

# Styling
circle.set_fill(RED, opacity=0.5)  # Set fill color and opacity
square.set_stroke(BLUE, width=10)  # Set stroke color and width
circle.set_color(GREEN)  # Set both fill and stroke color

# Transformations
circle.scale(2)  # Scale by a factor
square.rotate(PI/4)  # Rotate by an angle
circle.flip()  # Flip the mobject
```

#### Coordinate System:

Manim uses a 3D coordinate system where:

- The origin (0, 0, 0) is at the center of the screen
- The x-axis goes from left to right
- The y-axis goes from bottom to top
- The z-axis goes from the screen towards the viewer

Common position constants:

- `ORIGIN`: The center of the screen (0, 0, 0)
- `LEFT`, `RIGHT`, `UP`, `DOWN`: Unit vectors in each direction
- `UR`, `UL`, `DR`, `DL`: Diagonal unit vectors (Up-Right, Up-Left, etc.)

### Animations

Animations define how mobjects change over time.

#### Basic Animation Structure:

```python
self.play(Animation(mobject), run_time=1)
```

#### Common Animation Types:

```python
# Creation and removal
self.play(Create(circle))  # Create the circle
self.play(FadeIn(square))  # Fade in the square
self.play(FadeOut(circle))  # Fade out the circle
self.play(Uncreate(square))  # Uncreate the square

# Transformations
self.play(Transform(circle, square))  # Transform circle into square
self.play(ReplacementTransform(circle, square))  # Replace circle with square

# Movement
self.play(circle.animate.move_to([1, 2, 0]))  # Move to position
self.play(square.animate.shift(RIGHT))  # Shift right
self.play(MoveAlongPath(dot, circle))  # Move along a path

# Indication
self.play(Indicate(circle))  # Briefly highlight the circle
self.play(Flash(point))  # Flash at a point
self.play(CircleIndicate(square))  # Circle around the square
```

#### Animation Timing and Rate Functions:

```python
# Customize animation timing
self.play(Create(circle), run_time=2)  # Animation takes 2 seconds

# Customize animation pacing with rate functions
self.play(Create(circle), rate_func=linear)  # Constant speed
self.play(Create(square), rate_func=smooth)  # Ease in and out (default)
self.play(Create(triangle), rate_func=rush_into)  # Start slow, end fast
self.play(Create(pentagon), rate_func=rush_from)  # Start fast, end slow
```

Common rate functions:

- `linear`: Constant speed
- `smooth`: Ease in and out (default)
- `rush_into`: Start slow, end fast
- `rush_from`: Start fast, end slow
- `there_and_back`: Go to the end state and return to the start

### Scenes

Scenes are the containers for all animations.

#### Scene Lifecycle:

1. Scene is created
2. `construct()` method is called
3. Animations are played in sequence
4. Scene is rendered to video

#### Common Scene Methods:

```python
# Adding and removing objects
self.add(circle)  # Add object without animation
self.remove(circle)  # Remove object without animation

# Playing animations
self.play(Create(circle))  # Play a single animation
self.play(Create(circle), FadeIn(square))  # Play multiple animations simultaneously

# Waiting
self.wait(1)  # Wait for 1 second

# Clearing the screen
self.clear()  # Remove all objects from the scene
```

## 3. Basic Shapes and Transformations

### Creating Geometric Shapes

Manim provides a variety of built-in shapes:

```python
# Basic shapes
circle = Circle(radius=1.0)
square = Square(side_length=2.0)
rectangle = Rectangle(width=3.0, height=2.0)
triangle = Triangle()
polygon = RegularPolygon(n=6)  # Hexagon
ellipse = Ellipse(width=3.0, height=2.0)
arc = Arc(radius=1.0, start_angle=0, angle=PI)

# Lines and arrows
line = Line(start=LEFT, end=RIGHT)
arrow = Arrow(start=LEFT, end=RIGHT)
double_arrow = DoubleArrow(start=LEFT, end=RIGHT)
vector = Vector([1, 1, 0])

# Dots and points
dot = Dot(point=ORIGIN)
small_dot = Dot(point=ORIGIN, radius=0.05)

# Special shapes
annulus = Annulus(inner_radius=0.5, outer_radius=1.0)
star = Star(outer_radius=1.0, inner_radius=0.5)
```

### Customizing Shapes

```python
# Colors
circle.set_fill(RED, opacity=0.5)  # Fill with red at 50% opacity
square.set_stroke(BLUE, width=10)  # Blue outline with width 10
triangle.set_color(GREEN)  # Set both fill and stroke to green

# Gradients
rectangle.set_color_by_gradient(RED, BLUE)  # Gradient from red to blue
polygon.set_sheen_direction(UP)  # Direction of the sheen
polygon.set_sheen(0.5)  # Amount of sheen

# Dashed lines
line.set_stroke(width=3, color=YELLOW)
dashed_line = DashedLine(start=LEFT, end=RIGHT)
```

### Positioning and Arranging Shapes

```python
# Absolute positioning
circle.move_to([1, 2, 0])  # Move to coordinates
square.move_to(ORIGIN)  # Move to origin

# Relative positioning
square.next_to(circle, RIGHT)  # Place square to the right of circle
triangle.next_to(square, DOWN, buff=0.5)  # Add buffer space

# Edge alignment
rectangle.align_to(circle, LEFT)  # Align left edges
square.align_to(circle, UP)  # Align top edges

# Screen positioning
circle.to_edge(LEFT)  # Move to left edge of screen
square.to_corner(UR)  # Move to upper right corner

# Grouping objects
group = VGroup(circle, square, triangle)
group.arrange(DOWN)  # Arrange objects vertically
group.arrange_in_grid(rows=2, cols=2)  # Arrange in a grid
```

### Basic Transformations

```python
# Scaling
circle.scale(2)  # Scale by factor of 2
square.scale(0.5)  # Scale by factor of 0.5

# Rotation
triangle.rotate(PI/4)  # Rotate by 45 degrees
rectangle.rotate(PI, axis=RIGHT)  # Rotate around the x-axis

# Flipping
square.flip(axis=UP)  # Flip vertically
circle.flip(axis=RIGHT)  # Flip horizontally

# Stretching
rectangle.stretch(factor=2, dim=0)  # Stretch horizontally
rectangle.stretch(factor=0.5, dim=1)  # Compress vertically
```

### Complex Transformations

```python
# Transform one shape into another
self.play(Transform(circle, square))

# Replace one shape with another
self.play(ReplacementTransform(circle, square))

# Transform specific parts
self.play(TransformMatchingShapes(text1, text2))

# Morph between shapes
self.play(circle.animate.become(square))
```

## 4. Text and Mathematical Expressions

### Text Rendering with `Text` and `MarkupText`

```python
# Basic text
text = Text("Hello, Manim!")

# Font customization
text = Text("Custom Font", font="Arial")
text = Text("Bold Text", weight=BOLD)
text = Text("Italic Text", slant=ITALIC)

# Text styling
text = Text("Colored Text", color=BLUE)
text = Text("Gradient Text", gradient=(RED, BLUE))
text = Text("Large Text", font_size=72)

# Text with specific colors for parts
text = Text("Red and Blue", t2c={"Red": RED, "Blue": BLUE})

# Text with markup
markup_text = MarkupText("<b>Bold</b> and <i>Italic</i>")
markup_text = MarkupText("Colors: <span fgcolor='#ff0000'>Red</span> and <span fgcolor='#0000ff'>Blue</span>")
```

### LaTeX Rendering with `Tex` and `MathTex`

```python
# Basic LaTeX
tex = Tex(r"This is \LaTeX")

# Mathematical expressions
math_tex = MathTex(r"e^{i\pi} + 1 = 0")

# Multi-part expressions
eq = MathTex(r"f(x) = \frac{1}{1 + e^{-x}}")

# Breaking expressions into parts
eq_parts = MathTex(
    r"f(x)",
    r"=",
    r"\frac{1}{1 + e^{-x}}"
)
eq_parts[0].set_color(RED)  # Color the first part

# Aligning equations
aligned_eq = MathTex(r"""
    \begin{align}
    f(x) &= x^2 + 2x + 1 \\
    &= (x + 1)^2
    \end{align}
""")

# Using substrings_to_isolate for coloring specific parts
eq = MathTex(r"e^x = x^0 + x^1 + \frac{1}{2} x^2 + \cdots", substrings_to_isolate="x")
eq.set_color_by_tex("x", YELLOW)
```

### Equation Formatting and Styling

```python
# Size and positioning
eq = MathTex(r"E = mc^2", font_size=96)
eq.to_edge(UP)

# Colors
eq = MathTex(r"E = mc^2", color=BLUE)
eq = MathTex(r"E = mc^2", tex_to_color_map={"E": RED, "m": GREEN, "c": BLUE})

# Background
eq_with_bg = VGroup(
    BackgroundRectangle(eq, color=BLACK, fill_opacity=0.5),
    eq
)

# Braces and annotations
eq = MathTex(r"x^2 + y^2 = z^2")
brace = Brace(eq, direction=DOWN)
brace_text = brace.get_text("Pythagorean theorem")
```

### Animating Equation Transformations

```python
# Writing equations
self.play(Write(eq))

# Transform between equations
eq1 = MathTex(r"e^x = 1 + x + \frac{x^2}{2} + \cdots")
eq2 = MathTex(r"e^x = \sum_{n=0}^{\infty} \frac{x^n}{n!}")
self.play(TransformMatchingTex(eq1, eq2))

# Highlighting parts of equations
self.play(eq[0].animate.set_color(YELLOW))
self.play(Indicate(eq[1]))

# Revealing parts of equations
self.play(FadeIn(eq[0]))
self.play(FadeIn(eq[1]))
self.play(FadeIn(eq[2]))
```

## 5. Graphing and Coordinate Systems

### Creating Coordinate Systems

```python
# Number plane (2D coordinate system)
plane = NumberPlane(
    x_range=[-10, 10, 1],  # x_min, x_max, step
    y_range=[-5, 5, 1],    # y_min, y_max, step
    x_length=10,           # width
    y_length=6,            # height
    axis_config={"color": BLUE},
)

# Axes (without grid lines)
axes = Axes(
    x_range=[-10, 10, 1],
    y_range=[-5, 5, 1],
    x_length=10,
    y_length=6,
    axis_config={"include_tip": True}
)

# 3D axes
axes_3d = ThreeDAxes()

# Adding labels
x_label = axes.get_x_axis_label(r"x")
y_label = axes.get_y_axis_label(r"f(x)")
labels = VGroup(x_label, y_label)
```

### Plotting Functions

```python
# Basic function plot
def func(x):
    return x**2

graph = axes.plot(func, color=RED)

# Parametric function
parametric_curve = ParametricFunction(
    lambda t: np.array([np.cos(t), np.sin(t), 0]),
    t_range=[0, TAU],
    color=GREEN
)

# Multiple functions
sin_graph = axes.plot(lambda x: np.sin(x), color=BLUE)
cos_graph = axes.plot(lambda x: np.cos(x), color=RED)

# Function with limited domain
sqrt_graph = axes.plot(
    lambda x: np.sqrt(x),
    x_range=[0, 10],  # Only plot for x >= 0
    color=YELLOW
)
```

### Customizing Graphs

```python
# Graph styling
graph = axes.plot(
    func,
    color=BLUE,
    stroke_width=4,
    use_smoothing=True
)

# Adding graph labels
graph_label = axes.get_graph_label(
    graph,
    label=r"f(x) = x^2",
    x_val=5,
    direction=UR
)

# Highlighting points
dot = Dot().move_to(axes.c2p(2, func(2)))  # c2p = coords_to_point
point_label = MathTex(r"(2, 4)").next_to(dot, UP)

# Vertical and horizontal lines
v_line = axes.get_vertical_line(axes.c2p(2, func(2)))
h_line = axes.get_horizontal_line(axes.c2p(2, func(2)))
```

### Adding Points, Lines, and Areas to Graphs

```python
# Adding points
point = Dot(axes.c2p(2, func(2)), color=YELLOW)

# Adding lines
tangent_line = axes.get_secant_slope_group(
    x=2,
    graph=graph,
    dx=0.01,
    secant_line_color=GREEN,
    secant_line_length=4
)

# Adding areas
area = axes.get_area(
    graph,
    x_range=[0, 2],
    color=BLUE,
    opacity=0.5
)

# Riemann sums
riemann_rectangles = axes.get_riemann_rectangles(
    graph,
    x_range=[0, 5],
    dx=0.5,
    fill_opacity=0.5,
    colors=[BLUE, GREEN]
)
```

### Animating Graphs and Function Transformations

```python
# Creating a graph
self.play(Create(axes))
self.play(Create(graph), run_time=2)

# Transforming between functions
graph1 = axes.plot(lambda x: x**2, color=BLUE)
graph2 = axes.plot(lambda x: x**3, color=RED)
self.play(Transform(graph1, graph2))

# Tracing a point along a graph
dot = Dot(color=YELLOW)
dot.move_to(axes.c2p(0, 0))
self.add(dot)

x_tracker = ValueTracker(0)
dot.add_updater(
    lambda d: d.move_to(axes.c2p(x_tracker.get_value(), func(x_tracker.get_value())))
)
self.play(x_tracker.animate.set_value(5), run_time=3)
```

## 6. Advanced Animation Techniques

### Using `.animate` Syntax

The `.animate` syntax provides a convenient way to animate changes to mobjects:

```python
# Without .animate (static change)
circle.set_fill(RED)
self.add(circle)

# With .animate (animated change)
self.play(circle.animate.set_fill(RED))

# Chaining multiple animations
self.play(
    circle.animate.set_fill(RED).scale(2).shift(UP)
)

# Customizing animation parameters
self.play(
    circle.animate.set_fill(RED),
    run_time=2,
    rate_func=there_and_back
)
```

### Creating Custom Animations

```python
# Custom animation class
class CircleToSquare(Animation):
    def __init__(self, mobject, **kwargs):
        super().__init__(mobject, **kwargs)
        self.square = Square().match_width(mobject)

    def interpolate_mobject(self, alpha):
        # alpha goes from 0 to 1 during the animation
        self.mobject.become(
            VMobject().interpolate(
                self.mobject.copy(), self.square, alpha
            )
        )

# Using the custom animation
circle = Circle()
self.add(circle)
self.play(CircleToSquare(circle))
```

### Animation Composition

```python
# AnimationGroup plays animations in parallel
animations = AnimationGroup(
    Create(circle),
    FadeIn(square),
    run_time=2
)
self.play(animations)

# Succession plays animations sequentially
sequence = Succession(
    Create(circle),
    Wait(1),
    FadeIn(square),
    Wait(1)
)
self.play(sequence)

# LaggedStart plays animations with a delay between each
staggered = LaggedStart(
    *[FadeIn(dot) for dot in dots],
    lag_ratio=0.2,
    run_time=3
)
self.play(staggered)
```

### Using Updaters for Dynamic Animations

Updaters allow mobjects to change continuously based on other mobjects or time:

```python
# Simple updater that rotates a mobject over time
def rotate_updater(mobject, dt):
    mobject.rotate(dt)  # dt is the time since last frame

square = Square()
self.add(square)
square.add_updater(rotate_updater)
self.wait(2)  # Square will rotate for 2 seconds
square.remove_updater(rotate_updater)

# Updater that keeps one object next to another
dot = Dot()
text = Text("Follow me!").next_to(dot, RIGHT)
text.add_updater(lambda m: m.next_to(dot, RIGHT))
self.add(dot, text)
self.play(dot.animate.shift(UP + RIGHT))  # Text follows the dot

# Using always_redraw for continuous updates
always_changing = always_redraw(
    lambda: Circle(radius=np.sin(time.time()) + 1)
)
self.add(always_changing)
self.wait(5)  # Circle will pulsate for 5 seconds
```

### Value Trackers for Parametric Animations

Value trackers store values that can be animated and used to control other properties:

```python
# Create a value tracker
x = ValueTracker(0)

# Create a dot that follows the value
dot = Dot().add_updater(
    lambda d: d.move_to(axes.c2p(x.get_value(), func(x.get_value())))
)

# Create a label that shows the current value
label = DecimalNumber().add_updater(
    lambda d: d.set_value(x.get_value()).next_to(dot, UP)
)

self.add(dot, label)
self.play(x.animate.set_value(5), run_time=3)
```

## 7. 3D Visualizations

### Working with `ThreeDScene`

To create 3D animations, use the `ThreeDScene` class instead of `Scene`:

```python
from manim import *

class My3DScene(ThreeDScene):
    def construct(self):
        axes = ThreeDAxes()
        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
        self.add(axes)
        self.wait()
```

### Creating 3D Objects and Surfaces

```python
# Basic 3D shapes
cube = Cube(side_length=2, fill_opacity=0.7, color=BLUE)
sphere = Sphere(radius=1, fill_opacity=0.7, color=RED)
prism = Prism(dimensions=[1, 2, 3], fill_opacity=0.7, color=GREEN)

# Parametric surfaces
def param_surface_func(u, v):
    x = np.cos(u) * np.sin(v)
    y = np.sin(u) * np.sin(v)
    z = np.cos(v)
    return np.array([x, y, z])

param_surface = ParametricSurface(
    param_surface_func,
    u_range=[0, TAU],
    v_range=[0, PI],
    resolution=(16, 16),
    color=BLUE
)

# Function surfaces (z = f(x, y))
def func_surface(x, y):
    return np.sin(x) * np.cos(y)

surface = Surface(
    lambda u, v: np.array([u, v, func_surface(u, v)]),
    u_range=[-3, 3],
    v_range=[-3, 3],
    resolution=(16, 16),
    color=GREEN
)
```

### Camera Control and Orientation

```python
# Setting camera orientation
self.set_camera_orientation(
    phi=75 * DEGREES,    # Polar angle (up-down)
    theta=30 * DEGREES,  # Azimuthal angle (around)
    gamma=0 * DEGREES,   # Roll
    zoom=0.5             # Zoom level
)

# Moving the camera
self.move_camera(
    phi=45 * DEGREES,
    theta=60 * DEGREES,
    run_time=2
)

# Continuous camera rotation
self.begin_ambient_camera_rotation(rate=0.1)
self.wait(5)
self.stop_ambient_camera_rotation()

# 3D illusion effect
self.begin_3dillusion_camera_rotation(rate=0.2)
self.wait(5)
self.stop_3dillusion_camera_rotation()
```

### Lighting and Rendering Options

```python
# Changing the light source position
self.renderer.camera.light_source.move_to(3*IN + 3*LEFT)

# Adding ambient lighting
self.camera.set_ambient_light(color=BLUE, intensity=0.5)

# Changing the background color
self.camera.background_color = "#111111"
```

### Animating in 3D Space

```python
# Creating and animating 3D objects
cube = Cube()
self.play(Create(cube))
self.play(cube.animate.rotate(PI/2, axis=RIGHT))
self.play(cube.animate.shift(2*UP))

# Morphing between 3D objects
self.play(Transform(cube, sphere))

# Moving along a 3D path
curve = ParametricFunction(
    lambda t: np.array([np.cos(t), np.sin(t), t/2]),
    t_range=[0, 4*PI],
    color=YELLOW
)
dot = Dot3D(color=RED)
self.play(MoveAlongPath(dot, curve), run_time=5)
```

## 8. Special Effects and Techniques

### Camera Movements and Zooming

```python
# Using MovingCameraScene for camera control
class CameraMovementExample(MovingCameraScene):
    def construct(self):
        # Save the initial camera state
        self.camera.frame.save_state()

        # Zoom in
        self.play(self.camera.frame.animate.scale(0.5))

        # Move camera
        self.play(self.camera.frame.animate.shift(RIGHT*2))

        # Rotate camera
        self.play(self.camera.frame.animate.rotate(PI/4))

        # Restore original camera position
        self.play(Restore(self.camera.frame))

# Using ZoomedScene for magnified views
class ZoomedSceneExample(ZoomedScene):
    def construct(self):
        # Configure the zoomed camera
        self.camera.frame.move_to(ORIGIN)

        # Activate zooming
        self.activate_zooming(animate=True)

        # Move the zoomed area
        self.play(self.zoomed_camera.frame.animate.shift(RIGHT))
```

### Highlighting and Focusing Techniques

```python
# Surrounding with shapes
rect = SurroundingRectangle(text, color=YELLOW, buff=0.1)
circle = Circle().surround(text, buffer_factor=1.2)

# Indicating objects
self.play(Indicate(text))
self.play(Flash(point))
self.play(Circumscribe(formula))
self.play(ShowPassingFlash(line))

# Focusing with vignette
vignette = Rectangle(
    width=FRAME_WIDTH,
    height=FRAME_HEIGHT,
    fill_opacity=0.8,
    fill_color=BLACK,
    stroke_width=0
)
cutout = Circle(radius=2).move_to(text)
vignette.punch_out(cutout)
self.play(FadeIn(vignette))
```

### Creating Traces and Paths

```python
# Creating a path trace
def get_path_trace(mobject, time=1.0, color=YELLOW):
    path = VMobject()
    path.set_points_as_corners([mobject.get_center(), mobject.get_center()])

    def update_path(path):
        previous_path = path.copy()
        previous_path.add_points_as_corners([mobject.get_center()])
        path.become(previous_path)

    path.set_color(color)
    path.add_updater(update_path)
    return path

# Using the path trace
dot = Dot()
path = get_path_trace(dot)
self.add(dot, path)
self.play(dot.animate.move_to([3, 2, 0]), run_time=3)
```

### Using Color Gradients and Opacity

```python
# Color gradients
circle.set_color_by_gradient(RED, BLUE, GREEN)
line.set_color_by_gradient(YELLOW, PURPLE)

# Opacity gradients
def opacity_gradient(mob, start=0.2, end=1.0):
    n_submobs = len(mob.submobjects)
    for i, submob in enumerate(mob.submobjects):
        opacity = start + (end - start) * i / n_submobs
        submob.set_opacity(opacity)

dots = VGroup(*[Dot() for _ in range(10)]).arrange(RIGHT)
opacity_gradient(dots)
self.add(dots)
```

### Boolean Operations on Shapes

```python
# Union of shapes
union = Union(circle, square, color=GREEN, fill_opacity=0.5)

# Intersection of shapes
intersection = Intersection(circle, square, color=RED, fill_opacity=0.5)

# Difference of shapes
difference = Difference(circle, square, color=BLUE, fill_opacity=0.5)

# Exclusion of shapes
exclusion = Exclusion(circle, square, color=YELLOW, fill_opacity=0.5)
```

## 9. Best Practices and Optimization

### Code Organization for Complex Animations

```python
class WellOrganizedScene(Scene):
    def construct(self):
        # Setup phase - create all objects
        self.setup_objects()

        # Animation phase - play animations
        self.animate_first_part()
        self.animate_second_part()
        self.animate_conclusion()

    def setup_objects(self):
        # Create and configure all objects
        self.circle = Circle(radius=1.0, color=BLUE)
        self.square = Square(side_length=2.0, color=RED)
        self.text = Text("Organized Code", font_size=36)

        # Position objects
        self.square.next_to(self.circle, RIGHT)
        self.text.to_edge(UP)

    def animate_first_part(self):
        # First part of the animation
        self.play(Create(self.circle))
        self.play(Write(self.text))
        self.wait(0.5)

    def animate_second_part(self):
        # Second part of the animation
        self.play(Create(self.square))
        self.play(self.circle.animate.set_color(GREEN))
        self.wait(0.5)

    def animate_conclusion(self):
        # Conclusion of the animation
        self.play(
            self.circle.animate.scale(0.5),
            self.square.animate.scale(0.5),
            self.text.animate.scale(1.5)
        )
        self.wait(1)
```

### Performance Considerations

1. **Reuse Objects**: Create objects once and reuse them rather than recreating them.

```python
# Inefficient - creates a new circle each time
for i in range(10):
    self.play(Create(Circle()))

# Efficient - reuses the same circle
circle = Circle()
for i in range(10):
    self.play(Create(circle))
    self.play(FadeOut(circle))
```

2. **Group Animations**: Use `AnimationGroup` or multiple animations in a single `play` call.

```python
# Inefficient - separate play calls
self.play(Create(circle))
self.play(Create(square))
self.play(Create(triangle))

# Efficient - group animations
self.play(
    Create(circle),
    Create(square),
    Create(triangle)
)
```

3. **Use Appropriate Quality Settings**: Use lower quality settings during development.

```bash
# Development
manim -ql scene.py MyScene

# Final render
manim -qh scene.py MyScene
```

4. **Optimize Complex Shapes**: Reduce the number of points in complex shapes.

```python
# Inefficient - high resolution
circle = Circle(radius=1.0, n_components=128)

# Efficient - lower resolution for simple shapes
circle = Circle(radius=1.0, n_components=32)
```

5. **Cache Calculations**: Cache results of expensive calculations.

```python
# Inefficient - recalculates each time
def get_complex_point(t):
    # Expensive calculation
    return complex_calculation(t)

# Efficient - cache results
@functools.lru_cache(maxsize=128)
def get_complex_point(t):
    # Expensive calculation
    return complex_calculation(t)
```

### Common Patterns and Idioms

1. **Reveal Step by Step**: Gradually reveal complex diagrams or equations.

```python
equation = MathTex("E", "=", "m", "c^2")
self.play(Write(equation[0]))  # Show E
self.wait(0.5)
self.play(Write(equation[1]))  # Show =
self.wait(0.5)
self.play(Write(equation[2]))  # Show m
self.wait(0.5)
self.play(Write(equation[3]))  # Show c^2
```

2. **Highlight and Focus**: Draw attention to specific parts.

```python
self.play(Write(equation))
self.wait(1)
self.play(Indicate(equation[2]))  # Highlight m
self.wait(0.5)
self.play(Circumscribe(equation[3]))  # Circle c^2
```

3. **Transform Between Concepts**: Show relationships through transformations.

```python
circle = Circle(radius=1.0)
square = Square(side_length=2.0)
self.play(Create(circle))
self.wait(1)
self.play(Transform(circle, square))
```

4. **Use Updaters for Dynamic Relationships**: Keep related objects synchronized.

```python
dot = Dot()
line = Line(ORIGIN, RIGHT)
line.add_updater(lambda l: l.put_start_and_end_on(ORIGIN, dot.get_center()))
self.add(dot, line)
self.play(dot.animate.shift(2*UP + RIGHT))
```

5. **Create Reusable Components**: Define custom mobjects for repeated use.

```python
class LabeledArrow(VGroup):
    def __init__(self, label_text, **kwargs):
        super().__init__(**kwargs)
        self.arrow = Arrow(LEFT, RIGHT)
        self.label = Text(label_text)
        self.label.next_to(self.arrow, UP)
        self.add(self.arrow, self.label)

# Usage
labeled_arrow = LabeledArrow("Force")
self.play(Create(labeled_arrow))
```

### Debugging Techniques

1. **Add Debug Text**: Add temporary text to show variable values.

```python
def debug_text(label, value):
    text = Text(f"{label}: {value}", font_size=24)
    text.to_edge(DOWN)
    return text

x = 42
debug = debug_text("x", x)
self.add(debug)
```

2. **Use Color Coding**: Use colors to distinguish different parts.

```python
circle1 = Circle(color=RED)
circle2 = Circle(color=BLUE).shift(RIGHT)
self.add(circle1, circle2)
```

3. **Print to Console**: Use print statements for debugging.

```python
print(f"Circle position: {circle.get_center()}")
print(f"Animation duration: {self.renderer.time}")
```

4. **Isolate Components**: Test complex animations in smaller scenes.

```python
class DebugScene(Scene):
    def construct(self):
        # Test just one component
        self.test_equation_transform()

    def test_equation_transform(self):
        eq1 = MathTex("a^2 + b^2 = c^2")
        eq2 = MathTex("c = \\sqrt{a^2 + b^2}")
        self.play(Write(eq1))
        self.play(TransformMatchingTex(eq1, eq2))
```

5. **Use Sections**: Divide your animation into sections for easier debugging.

```python
self.next_section("Setup")
# Setup code here

self.next_section("First Animation")
# First animation code here

self.next_section("Second Animation")
# Second animation code here
```

### Reusing Components and Animations

1. **Create Custom Mobjects**: Extend existing mobjects for reuse.

```python
class NumberedDot(Dot):
    def __init__(self, number, **kwargs):
        super().__init__(**kwargs)
        self.label = Text(str(number), font_size=24)
        self.label.next_to(self, UP)
        self.add(self.label)

# Usage
dots = VGroup(*[NumberedDot(i) for i in range(1, 6)]).arrange(RIGHT)
self.play(Create(dots))
```

2. **Create Animation Templates**: Define functions that return common animations.

```python
def highlight_and_label(mobject, label_text):
    label = Text(label_text).next_to(mobject, UP)
    return Succession(
        Indicate(mobject),
        FadeIn(label)
    )

# Usage
self.play(highlight_and_label(circle, "Important Circle"))
```

3. **Use Inheritance for Similar Scenes**: Extend base scenes for similar animations.

```python
class GraphScene(Scene):
    def setup(self):
        self.axes = Axes()
        self.add(self.axes)

    def plot_function(self, func, color=BLUE):
        graph = self.axes.plot(func, color=color)
        self.play(Create(graph))
        return graph

# Usage
class ParabolaScene(GraphScene):
    def construct(self):
        self.setup()
        self.plot_function(lambda x: x**2)
```

4. **Create Animation Libraries**: Store common animations in separate files.

```python
# animations_lib.py
def appear_and_highlight(mobject):
    return Succession(
        FadeIn(mobject),
        Indicate(mobject),
        Flash(mobject.get_center())
    )

# main_scene.py
from animations_lib import appear_and_highlight

class MainScene(Scene):
    def construct(self):
        circle = Circle()
        self.play(appear_and_highlight(circle))
```

## 10. Common Examples and Templates

### Standard Mathematical Animations

#### Function Plotting

```python
class FunctionPlotExample(Scene):
    def construct(self):
        # Create axes
        axes = Axes(
            x_range=[-3, 3, 1],
            y_range=[-2, 2, 1],
            axis_config={"include_tip": False}
        )
        axes_labels = axes.get_axis_labels(x_label="x", y_label="f(x)")

        # Plot functions
        sin_graph = axes.plot(lambda x: np.sin(x), color=BLUE)
        cos_graph = axes.plot(lambda x: np.cos(x), color=RED)

        # Add labels
        sin_label = axes.get_graph_label(sin_graph, "\\sin(x)", x_val=2, direction=UP)
        cos_label = axes.get_graph_label(cos_graph, "\\cos(x)", x_val=2, direction=DOWN)

        # Group elements
        plots = VGroup(axes, sin_graph, cos_graph, axes_labels, sin_label, cos_label)

        # Display
        self.play(Create(axes), Create(axes_labels))
        self.play(Create(sin_graph), Create(sin_label))
        self.play(Create(cos_graph), Create(cos_label))
        self.wait()
```

#### Equation Transformations

```python
class EquationTransformExample(Scene):
    def construct(self):
        # Initial equation
        eq1 = MathTex("x^2", "+", "y^2", "=", "r^2")

        # Target equation
        eq2 = MathTex("\\frac{x^2}{a^2}", "+", "\\frac{y^2}{b^2}", "=", "1")

        # Display first equation
        self.play(Write(eq1))
        self.wait()

        # Transform to second equation
        self.play(TransformMatchingTex(eq1, eq2))
        self.wait()

        # Highlight parts
        self.play(Indicate(eq2[0]))  # Highlight x^2/a^2
        self.wait(0.5)
        self.play(Indicate(eq2[2]))  # Highlight y^2/b^2
        self.wait()
```

#### Geometric Transformations

```python
class GeometricTransformExample(Scene):
    def construct(self):
        # Create a square
        square = Square(side_length=2, color=BLUE)

        # Display the square
        self.play(Create(square))
        self.wait()

        # Rotate the square
        self.play(Rotate(square, PI/4))
        self.wait()

        # Scale the square
        self.play(square.animate.scale(0.5))
        self.wait()

        # Transform to circle
        circle = Circle(radius=1.5, color=RED)
        self.play(Transform(square, circle))
        self.wait()
```

### Physics Simulations

#### Simple Harmonic Motion

```python
class SimpleHarmonicMotion(Scene):
    def construct(self):
        # Create axes
        axes = Axes(
            x_range=[0, 10, 1],
            y_range=[-1.5, 1.5, 1],
            axis_config={"include_tip": False}
        )
        axes_labels = axes.get_axis_labels(x_label="t", y_label="x(t)")

        # Create the oscillating function
        def oscillation(t):
            return np.cos(2 * t) * np.exp(-0.1 * t)

        # Plot the function
        graph = axes.plot(oscillation, color=BLUE)

        # Create a dot that follows the graph
        dot = Dot(color=RED)
        dot.move_to(axes.c2p(0, oscillation(0)))

        # Create a vertical line that follows the dot
        line = always_redraw(
            lambda: axes.get_vertical_line(dot.get_center())
        )

        # Add everything to the scene
        self.play(Create(axes), Create(axes_labels))
        self.play(Create(graph))
        self.add(dot, line)

        # Animate the dot moving along the graph
        self.play(
            dot.animate.move_to(axes.c2p(10, oscillation(10))),
            rate_func=linear,
            run_time=10
        )
        self.wait()
```

#### Vector Field

```python
class VectorFieldExample(Scene):
    def construct(self):
        # Define a vector field function
        def field_func(pos):
            x, y = pos[:2]
            return np.array([-y, x, 0]) / (x**2 + y**2)**0.5

        # Create a vector field
        vector_field = ArrowVectorField(
            field_func,
            x_range=[-5, 5, 1],
            y_range=[-5, 5, 1],
            length_func=lambda norm: 0.5 * sigmoid(norm)
        )

        # Create streamlines
        streamlines = StreamLines(
            field_func,
            x_range=[-5, 5, 0.2],
            y_range=[-5, 5, 0.2],
            stroke_width=2,
            color=BLUE
        )

        # Add animation
        self.add(vector_field)
        self.play(Create(streamlines, lag_ratio=0.01, run_time=3))
        self.wait()

        # Animate a particle moving along a streamline
        dot = Dot(color=RED)
        dot.move_to([-3, -3, 0])

        def update_dot(dot, dt):
            pos = dot.get_center()
            field_val = field_func(pos)
            dot.shift(field_val * dt)

        dot.add_updater(update_dot)
        self.add(dot)
        self.wait(10)
```

### Algorithm Visualizations

#### Sorting Algorithm

```python
class BubbleSortVisualization(Scene):
    def construct(self):
        # Create a list of values
        values = [7, 3, 1, 8, 5, 4, 6, 2]

        # Create bars representing the values
        bars = VGroup()
        for val in values:
            bar = Rectangle(height=val * 0.5, width=0.8, fill_opacity=0.8, color=BLUE)
            bars.add(bar)

        bars.arrange(RIGHT, buff=0.2)
        bars.move_to(ORIGIN)

        # Add labels
        labels = VGroup()
        for i, bar in enumerate(bars):
            label = Text(str(values[i]), font_size=24)
            label.next_to(bar, DOWN)
            labels.add(label)

        # Display initial state
        self.play(Create(bars), Write(labels))
        self.wait()

        # Bubble sort animation
        def update_bars(bars, values):
            for i, (bar, val) in enumerate(zip(bars, values)):
                bar.height = val * 0.5
                bar.stretch_to_fit_height(val * 0.5)
                bar.move_to(bars[i].get_center())

        def update_labels(labels, values):
            for i, (label, val) in enumerate(zip(labels, values)):
                new_label = Text(str(val), font_size=24)
                new_label.next_to(bars[i], DOWN)
                labels[i].become(new_label)

        # Perform bubble sort
        n = len(values)
        for i in range(n):
            for j in range(0, n - i - 1):
                # Highlight bars being compared
                self.play(
                    bars[j].animate.set_color(RED),
                    bars[j + 1].animate.set_color(RED),
                    run_time=0.5
                )

                if values[j] > values[j + 1]:
                    # Swap values
                    values[j], values[j + 1] = values[j + 1], values[j]

                    # Animate the swap
                    self.play(
                        bars[j].animate.move_to(bars[j + 1].get_center()),
                        bars[j + 1].animate.move_to(bars[j].get_center()),
                        labels[j].animate.next_to(bars[j + 1], DOWN),
                        labels[j + 1].animate.next_to(bars[j], DOWN),
                        run_time=1
                    )

                    # Update the bars and labels
                    bars[j], bars[j + 1] = bars[j + 1], bars[j]
                    labels[j], labels[j + 1] = labels[j + 1], labels[j]

                # Reset colors
                self.play(
                    bars[j].animate.set_color(BLUE),
                    bars[j + 1].animate.set_color(BLUE),
                    run_time=0.5
                )

        # Highlight sorted array
        self.play(
            bars.animate.set_color(GREEN),
            run_time=1
        )
        self.wait()
```

#### Graph Algorithm

```python
class GraphTraversalExample(Scene):
    def construct(self):
        # Create a graph
        vertices = [
            [0, 0, 0],    # 0
            [-1, 1, 0],   # 1
            [1, 1, 0],    # 2
            [-2, 0, 0],   # 3
            [0, -1, 0],   # 4
            [2, 0, 0]     # 5
        ]

        edges = [
            (0, 1), (0, 2), (0, 4),
            (1, 3), (2, 5), (4, 5)
        ]

        # Create the graph visualization
        g = Graph(
            vertices=list(range(len(vertices))),
            edges=edges,
            layout={i: v for i, v in enumerate(vertices)},
            vertex_config={"radius": 0.3, "color": BLUE},
            edge_config={"stroke_width": 2}
        )

        # Add vertex labels
        labels = VGroup()
        for i, v in enumerate(vertices):
            label = Text(str(i), font_size=24)
            label.move_to(v)
            labels.add(label)

        # Display the graph
        self.play(Create(g))
        self.play(Write(labels))
        self.wait()

        # BFS traversal
        visited = set()
        queue = [0]  # Start from vertex 0

        while queue:
            vertex = queue.pop(0)

            if vertex in visited:
                continue

            # Mark as visited
            visited.add(vertex)
            self.play(
                g.vertices[vertex].animate.set_color(RED),
                run_time=0.5
            )

            # Add neighbors to queue
            for u, v in edges:
                if u == vertex and v not in visited:
                    queue.append(v)
                    self.play(
                        g.edges[(u, v)].animate.set_color(YELLOW),
                        run_time=0.5
                    )
                elif v == vertex and u not in visited:
                    queue.append(u)
                    self.play(
                        g.edges[(u, v)].animate.set_color(YELLOW),
                        run_time=0.5
                    )

        # Highlight all visited vertices
        self.play(
            *[g.vertices[v].animate.set_color(GREEN) for v in visited],
            run_time=1
        )
        self.wait()
```

### Educational Diagram Animations

#### Pythagorean Theorem

```python
class PythagoreanTheorem(Scene):
    def construct(self):
        # Create a right triangle
        triangle = Polygon(
            ORIGIN, RIGHT * 3, UP * 4,
            color=WHITE, fill_opacity=0.2
        )

        # Label the sides
        a_label = MathTex("a").next_to(triangle, DOWN)
        b_label = MathTex("b").next_to(triangle, RIGHT)
        c_label = MathTex("c").next_to(triangle.get_center(), UL)

        # Create squares on each side
        a_square = Square(side_length=3, color=RED, fill_opacity=0.3)
        a_square.next_to(triangle, DOWN, buff=0)
        a_square.shift(RIGHT * 1.5)

        b_square = Square(side_length=4, color=GREEN, fill_opacity=0.3)
        b_square.next_to(triangle, RIGHT, buff=0)
        b_square.shift(UP * 2)

        c_square = Polygon(
            ORIGIN, RIGHT * 3, RIGHT * 3 + UP * 4, UP * 4,
            color=BLUE, fill_opacity=0.3
        )
        c_square.rotate(PI/4, about_point=ORIGIN)
        c_square.shift(RIGHT * 1.5 + UP * 2)

        # Label the areas
        a_area = MathTex("a^2").move_to(a_square)
        b_area = MathTex("b^2").move_to(b_square)
        c_area = MathTex("c^2").move_to(c_square)

        # Create the equation
        equation = MathTex("a^2", "+", "b^2", "=", "c^2")
        equation.to_edge(UP)

        # Display the triangle
        self.play(Create(triangle))
        self.play(Write(a_label), Write(b_label), Write(c_label))
        self.wait()

        # Show the squares
        self.play(
            Create(a_square),
            Create(b_square),
            Create(c_square)
        )
        self.play(
            Write(a_area),
            Write(b_area),
            Write(c_area)
        )
        self.wait()

        # Show the equation
        self.play(
            TransformFromCopy(a_area, equation[0]),
            Write(equation[1]),
            TransformFromCopy(b_area, equation[2]),
            Write(equation[3]),
            TransformFromCopy(c_area, equation[4])
        )
        self.wait(2)
```

#### Derivative Visualization

```python
class DerivativeVisualization(Scene):
    def construct(self):
        # Create axes
        axes = Axes(
            x_range=[-1, 5],
            y_range=[-1, 5],
            axis_config={"include_tip": False}
        )
        axes_labels = axes.get_axis_labels(x_label="x", y_label="f(x)")

        # Define function
        def func(x):
            return x**2 / 4 + 0.5

        # Create graph
        graph = axes.plot(func, color=BLUE)
        graph_label = MathTex("f(x) = \\frac{x^2}{4} + 0.5")
        graph_label.to_corner(UL)

        # Display axes and graph
        self.play(Create(axes), Create(axes_labels))
        self.play(Create(graph), Write(graph_label))
        self.wait()

        # Create a point on the graph
        x_tracker = ValueTracker(1)

        dot = Dot(color=RED)
        dot.add_updater(
            lambda d: d.move_to(axes.c2p(x_tracker.get_value(), func(x_tracker.get_value())))
        )

        # Create the tangent line
        tangent = always_redraw(
            lambda: axes.get_secant_slope_group(
                x=x_tracker.get_value(),
                graph=graph,
                dx=0.01,
                secant_line_color=GREEN,
                secant_line_length=4
            )
        )

        # Create the derivative label
        derivative_label = always_redraw(
            lambda: MathTex(f"f'({x_tracker.get_value():.1f}) = {x_tracker.get_value() / 2:.2f}")
                .next_to(dot, UR)
                .scale(0.8)
        )

        # Add everything to the scene
        self.play(Create(dot), Create(tangent), Write(derivative_label))
        self.wait()

        # Move the point along the graph
        self.play(x_tracker.animate.set_value(4), run_time=8)
        self.wait()
```

## 11. Reference Tables

### Common Mobjects

| Mobject       | Description        | Example                                  |
| ------------- | ------------------ | ---------------------------------------- |
| `Circle`      | A circle shape     | `Circle(radius=1.0, color=RED)`          |
| `Square`      | A square shape     | `Square(side_length=2.0, color=BLUE)`    |
| `Rectangle`   | A rectangle shape  | `Rectangle(width=3.0, height=2.0)`       |
| `Triangle`    | A triangle shape   | `Triangle(color=GREEN)`                  |
| `Polygon`     | A custom polygon   | `Polygon(ORIGIN, RIGHT, UP)`             |
| `Line`        | A straight line    | `Line(start=LEFT, end=RIGHT)`            |
| `Arrow`       | An arrow           | `Arrow(start=LEFT, end=RIGHT)`           |
| `Dot`         | A point            | `Dot(point=ORIGIN, radius=0.1)`          |
| `Text`        | Regular text       | `Text("Hello Manim", font_size=36)`      |
| `Tex`         | LaTeX text         | `Tex(r"\LaTeX")`                         |
| `MathTex`     | LaTeX math         | `MathTex(r"e^{i\pi} + 1 = 0")`           |
| `NumberPlane` | 2D coordinate grid | `NumberPlane()`                          |
| `Axes`        | Coordinate axes    | `Axes(x_range=[-5, 5], y_range=[-5, 5])` |
| `VGroup`      | Group of mobjects  | `VGroup(circle, square, triangle)`       |

### Animation Types

| Animation              | Description                        | Example                                          |
| ---------------------- | ---------------------------------- | ------------------------------------------------ |
| `Create`               | Draw a mobject                     | `Create(circle)`                                 |
| `FadeIn`               | Fade in a mobject                  | `FadeIn(square)`                                 |
| `FadeOut`              | Fade out a mobject                 | `FadeOut(circle)`                                |
| `Transform`            | Transform one mobject into another | `Transform(circle, square)`                      |
| `ReplacementTransform` | Replace one mobject with another   | `ReplacementTransform(circle, square)`           |
| `Write`                | Write text                         | `Write(text)`                                    |
| `Indicate`             | Briefly highlight a mobject        | `Indicate(circle)`                               |
| `Rotate`               | Rotate a mobject                   | `Rotate(square, angle=PI/4)`                     |
| `MoveAlongPath`        | Move a mobject along a path        | `MoveAlongPath(dot, circle)`                     |
| `AnimationGroup`       | Group animations                   | `AnimationGroup(Create(circle), FadeIn(square))` |
| `Succession`           | Play animations in sequence        | `Succession(Create(circle), FadeIn(square))`     |
| `LaggedStart`          | Play animations with a delay       | `LaggedStart(*[Create(dot) for dot in dots])`    |

### Color Constants

| Constant | Color  | Hex Code  |
| -------- | ------ | --------- |
| `WHITE`  | White  | `#FFFFFF` |
| `BLACK`  | Black  | `#000000` |
| `RED`    | Red    | `#FF0000` |
| `GREEN`  | Green  | `#00FF00` |
| `BLUE`   | Blue   | `#0000FF` |
| `YELLOW` | Yellow | `#FFFF00` |
| `PURPLE` | Purple | `#800080` |
| `ORANGE` | Orange | `#FF7F00` |
| `PINK`   | Pink   | `#FF69B4` |
| `GRAY`   | Gray   | `#888888` |

### Positioning Constants

| Constant | Direction     | Value         |
| -------- | ------------- | ------------- |
| `ORIGIN` | Center        | `[0, 0, 0]`   |
| `UP`     | Up            | `[0, 1, 0]`   |
| `DOWN`   | Down          | `[0, -1, 0]`  |
| `LEFT`   | Left          | `[-1, 0, 0]`  |
| `RIGHT`  | Right         | `[1, 0, 0]`   |
| `UR`     | Up-Right      | `[1, 1, 0]`   |
| `UL`     | Up-Left       | `[-1, 1, 0]`  |
| `DR`     | Down-Right    | `[1, -1, 0]`  |
| `DL`     | Down-Left     | `[-1, -1, 0]` |
| `IN`     | Into screen   | `[0, 0, 1]`   |
| `OUT`    | Out of screen | `[0, 0, -1]`  |

### Command-line Arguments

| Argument | Description                             | Example                                 |
| -------- | --------------------------------------- | --------------------------------------- |
| `-p`     | Preview the animation                   | `manim -p scene.py MyScene`             |
| `-l`     | Low quality (faster)                    | `manim -l scene.py MyScene`             |
| `-m`     | Medium quality                          | `manim -m scene.py MyScene`             |
| `-h`     | High quality                            | `manim -h scene.py MyScene`             |
| `-k`     | Keep animation playing in a loop        | `manim -pk scene.py MyScene`            |
| `-s`     | Skip to the end and show the last frame | `manim -s scene.py MyScene`             |
| `-q`     | Quiet mode (less output)                | `manim -q scene.py MyScene`             |
| `-f`     | Show the file in the file browser       | `manim -f scene.py MyScene`             |
| `-a`     | Render all scenes in the file           | `manim -a scene.py`                     |
| `-o`     | Specify the output file name            | `manim -o custom_name scene.py MyScene` |
