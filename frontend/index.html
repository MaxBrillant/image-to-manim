<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Image to Manim</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <!-- Add Marked.js for markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Add GitHub-like markdown CSS -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/github-markdown-css@5.2.0/github-markdown-light.css"
    />
    <style>
      body {
        font-family: Arial, sans-serif;
        background-color: #f4f4f9;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        position: relative;
        overflow-y: auto;
      }
      #container {
        background-color: #fff;
        padding: 1.25rem;
        border-radius: 0.5rem;
        box-shadow: 0 0 0.625rem rgba(0, 0, 0, 0.1);
        text-align: center;
        max-width: 30rem;
        width: 90%;
      }
      h1 {
        color: #333;
      }
      a {
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
      form {
        margin-bottom: 1.25rem;
      }
      .file-upload {
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative;
      }
      .file-upload-input {
        display: none;
      }
      .file-upload-label {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        aspect-ratio: 2/1;
        border: 0.125rem dashed #ccc;
        border-radius: 0.5rem;
        background-color: #f8f8f8;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-bottom: 0.9375rem;
      }
      .file-upload-label:hover {
        border-color: #007bff;
        background-color: #f0f7ff;
      }
      .file-upload-label-text {
        color: #666;
        font-size: 1rem;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .file-upload-icon {
        font-size: 1.5rem;
        margin-bottom: 0.5rem;
        color: #007bff;
      }
      .image-preview-container {
        width: 100%;
        max-height: 12.5rem;
        overflow: hidden;
        margin-bottom: 0.9375rem;
        border-radius: 0.5rem;
        display: none;
        border: 0.0625rem solid #ddd;
        position: relative;
      }
      .image-preview {
        width: 100%;
        height: auto;
        object-fit: contain;
        max-height: 12.5rem;
      }

      .change-image-btn {
        position: absolute;
        bottom: 0.625rem;
        right: 0.625rem;
        background-color: rgba(225, 225, 225, 0.8);
        color: rgb(70, 70, 70);
        border: 0.0625rem solid #363636;
        border-radius: 0.25rem;
        padding: 0.3125rem 0.625rem;
        font-size: 0.75rem;
        cursor: pointer;
        z-index: 10;
      }

      .change-image-btn:hover {
        background-color: rgba(225, 225, 225, 0.7);
      }
      .submit-button {
        width: 100%;
        background-color: #007bff;
        color: #fff;
        border: none;
        padding: 0.625rem 1.25rem;
        border-radius: 0.25rem;
        cursor: pointer;
        transition: all 0.3s ease;
        display: none; /* Hidden by default */
      }
      button:hover {
        background-color: #0056b3;
      }

      /* Step processing styles */
      .process-steps {
        display: flex;
        flex-direction: column;
        width: 100%;
        margin-top: 1.25rem;
      }
      .step {
        border: 1px solid #a0a0a0;
        border-radius: 0.5rem;
        padding: 1rem;
        margin-bottom: 1rem;
        display: flex;
        flex-direction: column;
        text-align: left;
        position: relative;
      }
      .step.pending {
        display: none;
      }
      .step-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.2rem;
      }
      .step-title {
        font-weight: bold;
        font-size: 1.1rem;
        color: #333;
      }
      .step-status {
        font-size: 0.9rem;
      }
      .step-status.pending {
        color: #888;
      }
      .step-status.processing {
        color: #007bff;
      }
      .step-status.completed {
        color: #28a745;
      }
      .step-status.error {
        color: #dc3545;
      }
      .step-content {
        display: none;
      }
      .step-spinner {
        display: none;
        margin-left: 0.5rem;
        width: 1rem;
        height: 1rem;
        border: 2px solid #f3f3f3;
        border-top: 2px solid #007bff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      .step-timer {
        color: #666;
        margin-top: 0.5rem;
        display: none;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      .step-content pre {
        background-color: #f0f0f0;
        padding: 0.75rem;
        border-radius: 0.25rem;
        overflow-x: auto;
        white-space: pre-wrap;
        font-size: 0.85rem;
        color: #333;
      }

      .markdown-content {
        max-height: 15rem;
        background-color: #f0f0f0;
        padding: 0.75rem;
        margin-top: 0.5rem;
        margin-bottom: 0.5rem;
        border-radius: 0.25rem;
        overflow-x: auto;
        font-size: 0.95rem;
        line-height: 1.5;
        color: #333;
      }

      .markdown-content pre {
        background-color: #f5f5f5;
        padding: 0.5rem;
        border-radius: 0.25rem;
        overflow-x: auto;
        margin-bottom: 1rem;
      }

      .markdown-content code {
        background-color: #f0f0f0;
        padding: 0.125rem 0.25rem;
        border-radius: 0.25rem;
        font-family: monospace;
      }
      .step-buttons {
        display: flex;
        justify-content: flex-end;
      }
      .try-again-button,
      .cancel-button {
        border: none;
        border-radius: 0.25rem;
        padding: 0.5rem 1rem;
        cursor: pointer;
        font-size: 0.9rem;
        display: none;
      }
      .try-again-button:hover,
      .cancel-button:hover {
        background-color: transparent;
      }
      .video-container {
        margin-top: 1rem;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        object-fit: contain;
      }
      .video-player {
        width: 100%;
        height: auto;
        border-radius: 0.25rem;
        object-fit: contain;
      }

      .footer {
        text-align: center;
        padding: 0.625rem 0;
        margin-top: 1.25rem;
        font-size: 0.875rem;
        color: #666;
        width: 100%;
      }
      .github-link {
        color: #373737;
        text-decoration: none;
        margin-left: 3.125rem;
      }
    </style>
    <script>
      let currentSessionId = null;
      let currentController = null;
      let apiUrl = "https://image-to-manim.onrender.com"; // Replace with your API URL
      // For local development, uncomment this line:
      // let apiUrl = "http://localhost:5000";

      // Track the state of each step
      const stepsState = {
        processImage: { status: "pending", data: null, retryCount: 0 },
        generateScript: { status: "pending", data: null, retryCount: 0 },
        generateVisuals: { status: "pending", data: null, retryCount: 0 },
        generateVideo: { status: "pending", data: null, retryCount: 0 },
        improveVideo: { status: "pending", data: null, retryCount: 0 },
      };

      // Retry configuration
      const retryConfig = {
        maxRetries: 5,
        retryDelay: 3000, // 5 seconds between retries
      };

      // Step sequence for automatic progression and retry functionality
      const stepSequence = [
        "processImage",
        "generateScript",
        "generateVisuals",
        "generateVideo",
        "improveVideo",
      ];

      // Timer handlers for each step
      const stepTimers = {
        processImage: { startTime: null, interval: null },
        generateScript: { startTime: null, interval: null },
        generateVisuals: { startTime: null, interval: null },
        generateVideo: { startTime: null, interval: null },
        improveVideo: { startTime: null, interval: null },
      };

      function startStepTimer(stepKey) {
        const stepId = `step-${stepKey}`;
        const timerElem = document.getElementById(`${stepId}-timer`);
        if (!timerElem) return;

        // Reset and start timer
        stepTimers[stepKey].startTime = Date.now();
        timerElem.style.display = "block";

        // Clear any existing interval
        if (stepTimers[stepKey].interval) {
          clearInterval(stepTimers[stepKey].interval);
        }

        // Update immediately and then start interval
        updateStepTimer(stepKey);
        stepTimers[stepKey].interval = setInterval(
          () => updateStepTimer(stepKey),
          1000
        );
      }

      function updateStepTimer(stepKey) {
        const stepId = `step-${stepKey}`;
        const timerElem = document.getElementById(`${stepId}-timer`);
        if (!timerElem || !stepTimers[stepKey].startTime) return;

        const elapsedTime = Math.floor(
          (Date.now() - stepTimers[stepKey].startTime) / 1000
        );
        const minutes = Math.floor(elapsedTime / 60);
        const seconds = elapsedTime % 60;
        timerElem.textContent = `${minutes > 0 ? minutes + "m " : ""}${
          seconds < 10 ? "0" + seconds : seconds
        }s`;
      }

      function stopStepTimer(stepKey) {
        if (stepTimers[stepKey].interval) {
          clearInterval(stepTimers[stepKey].interval);
          stepTimers[stepKey].interval = null;
        }
      }

      // Helper function to check if any step is currently processing
      function isAnyStepProcessing() {
        return Object.values(stepsState).some(
          (step) => step.status === "processing"
        );
      }

      // Function to update all try-again buttons based on processing state
      function updateAllTryAgainButtons() {
        const isProcessing = isAnyStepProcessing();

        // Hide all try-again buttons if any step is processing
        stepSequence.forEach((stepKey) => {
          const stepId = `step-${stepKey}`;
          const step = document.getElementById(stepId);
          const tryAgainBtn = step.querySelector(".try-again-button");

          if (tryAgainBtn) {
            // Only show button if the step is completed/error AND no step is processing
            const shouldShow =
              (stepsState[stepKey].status === "completed" ||
                stepsState[stepKey].status === "error") &&
              !isProcessing;
            tryAgainBtn.style.display = shouldShow ? "inline-block" : "none";
          }
        });
      }

      // Function to handle request cancellation
      async function handleCancel(stepKey) {
        if (currentController) {
          currentController.abort();
          currentController = null;

          // Update step status to error and show cancelled message
          updateStepStatus(`step-${stepKey}`, "error", "CANCELLED");
          setStepContent(`step-${stepKey}`, "Request cancelled", "text");
        }
      }

      function updateStepStatus(stepId, status, message = null) {
        const step = document.getElementById(stepId);
        const statusElem = step.querySelector(".step-status");
        const spinner = step.querySelector(".step-spinner");
        const stepKey = stepId.replace("step-", "");

        // Update cancel button visibility
        const cancelBtn = step.querySelector(".cancel-button");
        if (cancelBtn) {
          cancelBtn.style.display =
            status === "processing" ? "inline-block" : "none";
        }

        // Update CSS classes based on status
        step.className = `step ${status}`;
        statusElem.textContent = message || status.toUpperCase();
        statusElem.className = "step-status " + status;

        // Previous status before update
        const previousStatus = stepsState[stepKey].status;

        // Update our state object
        stepsState[stepKey].status = status;

        if (status === "processing") {
          spinner.style.display = "inline-block";

          // Start timer for this step if it's not already running
          if (!stepTimers[stepKey].interval) {
            startStepTimer(stepKey);
          }
        } else if (status === "completed" || status === "error") {
          spinner.style.display = "none";
          // Only stop timer on completion or final error
          stopStepTimer(stepKey);
        } else {
          spinner.style.display = "none";
        }

        // Update all try-again buttons visibility
        updateAllTryAgainButtons();

        // If completed, automatically trigger the next step
        if (status === "completed") {
          const currentStepIndex = stepSequence.indexOf(stepKey);
          if (
            currentStepIndex >= 0 &&
            currentStepIndex < stepSequence.length - 1
          ) {
            const nextStepKey = stepSequence[currentStepIndex + 1];
            setTimeout(() => {
              executeStep(nextStepKey);
            }, 1000); // Small delay before starting next step
          }
        }
      }

      function showStepContent(stepId, show = true) {
        const content = document.getElementById(`${stepId}-content`);
        if (content) {
          content.style.display = show ? "block" : "none";
        }
      }

      function setStepContent(stepId, content, contentType = "text") {
        const contentElem = document.getElementById(`${stepId}-content`);

        if (contentType === "json") {
          contentElem.innerHTML = `<pre>${JSON.stringify(
            content,
            null,
            2
          )}</pre>`;
        } else if (contentType === "text") {
          // Check if this is a step that should render markdown
          if (
            stepId === "step-processImage" ||
            stepId === "step-generateScript" ||
            stepId === "step-generateVisuals"
          ) {
            try {
              // Use marked.js to parse markdown
              const htmlContent = marked.parse(content);
              contentElem.innerHTML = `<div class="markdown-content">${htmlContent}</div>`;
            } catch (err) {
              // Fallback to regular text if markdown parsing fails
              contentElem.innerHTML = `<pre>${content}</pre>`;
              console.error("Failed to parse markdown:", err);
            }
          } else {
            // Other content displayed as regular text
            contentElem.innerHTML = `<pre>${content}</pre>`;
          }
        } else if (contentType === "video") {
          contentElem.innerHTML = `
            <div class="video-container">
              <video class="video-player" controls autoplay>
                <source src="${content}" type="video/mp4">
                Your browser does not support the video tag.
              </video>
              <p><a href="${content}" target="_blank">Open video in new tab</a></p>
            </div>
          `;
        } else if (contentType === "html") {
          contentElem.innerHTML = content;
        }

        showStepContent(stepId, true);
      }

      function handleImageSelection(event) {
        const file = event.target.files[0];
        if (file && file.type.startsWith("image/")) {
          const reader = new FileReader();
          const previewContainer = document.getElementById(
            "imagePreviewContainer"
          );
          const preview = document.getElementById("imagePreview");
          const fileUploadLabel = document.querySelector(".file-upload-label");
          const submitButton = document.querySelector(".submit-button");

          reader.onload = function (e) {
            preview.src = e.target.result;

            // Hide the file picker and show the preview and submit button
            fileUploadLabel.style.display = "none";
            previewContainer.style.display = "block";
            submitButton.style.display = "inline-block";

            // Make sure the change image button exists
            if (!document.querySelector(".change-image-btn")) {
              const changeBtn = document.createElement("button");
              changeBtn.className = "change-image-btn";
              changeBtn.textContent = "Change Image";
              changeBtn.onclick = function (e) {
                e.preventDefault();
                // Trigger the file input click to open the file picker dialog
                document.getElementById("imageInput").click();
              };
              previewContainer.appendChild(changeBtn);
            }
          };

          reader.readAsDataURL(file);
        }
      }

      // Function to execute a specific step
      function executeStep(stepKey) {
        const stepMap = {
          processImage: processImage,
          generateScript: generateScript,
          generateVisuals: generateVisuals,
          generateVideo: generateVideo,
          improveVideo: improveVideo,
        };

        if (stepMap[stepKey]) {
          stepMap[stepKey]();
        }
      }

      // Generate Visual Elements
      async function generateVisuals() {
        if (!currentSessionId) {
          console.error("No session ID available");
          return;
        }

        // Update step status
        updateStepStatus("step-generateVisuals", "processing", "PROCESSING");

        try {
          // Create new AbortController for this request
          currentController = new AbortController();
          const signal = currentController.signal;

          const response = await fetch(`${apiUrl}/generate-visuals`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              session_id: currentSessionId,
            }),
            signal: signal,
          });

          if (!response.ok) {
            throw new Error(`Server responded with status: ${response.status}`);
          }

          const result = await response.json();

          if (result.visuals_text) {
            // Update step status and content
            updateStepStatus("step-generateVisuals", "completed", "COMPLETED");
            setStepContent("step-generateVisuals", result.visuals_text, "text");

            // Store data in our state
            stepsState.generateVisuals.data = result;
          } else {
            throw new Error(
              result.error || "Failed to generate visual elements"
            );
          }
        } catch (error) {
          // Don't retry if the request was cancelled
          if (error.name === "AbortError") {
            return;
          }

          if (stepsState.generateVisuals.retryCount < retryConfig.maxRetries) {
            // Increment retry count
            stepsState.generateVisuals.retryCount++;

            // Update status with retry attempt
            updateStepStatus(
              "step-generateVisuals",
              "processing",
              `RETRYING (${stepsState.generateVisuals.retryCount}/${retryConfig.maxRetries})`
            );

            // Show retry message
            setStepContent(
              "step-generateVisuals",
              `Error encountered: ${error.message}\nRetrying in ${
                retryConfig.retryDelay / 1000
              } seconds... (Attempt ${stepsState.generateVisuals.retryCount}/${
                retryConfig.maxRetries
              })`,
              "text"
            );

            // Retry after delay
            setTimeout(() => generateVisuals(), retryConfig.retryDelay);
          } else {
            // Max retries reached, show error
            updateStepStatus("step-generateVisuals", "error", "ERROR");
            setStepContent(
              "step-generateVisuals",
              `Error: ${error.message}\nMax retry attempts (${retryConfig.maxRetries}) reached.`,
              "text"
            );
          }
        }
      }

      // Function to try again from a specific step
      function tryAgainFromStep(stepKey) {
        // Reset current and all following steps
        const startIndex = stepSequence.indexOf(stepKey);
        if (startIndex >= 0) {
          for (let i = startIndex; i < stepSequence.length; i++) {
            const resetStepKey = stepSequence[i];
            stepsState[resetStepKey].status = "pending";
            stepsState[resetStepKey].data = null;
            stepsState[resetStepKey].retryCount = 0; // Reset retry counter
            updateStepStatus(`step-${resetStepKey}`, "pending", "PENDING");
            showStepContent(`step-${resetStepKey}`, false);
          }

          // Start execution from the selected step
          executeStep(stepKey);
        }
      }

      // Step 1: Process Image
      async function processImage(event) {
        if (event) event.preventDefault();

        // Reset all steps if starting a new process
        if (currentSessionId === null) {
          for (const step in stepsState) {
            stepsState[step].status = "pending";
            stepsState[step].data = null;
            stepsState[step].retryCount = 0; // Reset retry counter
            updateStepStatus(`step-${step}`, "pending", "PENDING");
            showStepContent(`step-${step}`, false);
          }
        }

        const formData = new FormData(document.getElementById("imageForm"));
        const submitButton = document.querySelector(".submit-button");
        const changeImageButton = document.querySelector(".change-image-btn");

        // Update UI
        submitButton.style.display = "none";
        changeImageButton.style.display = "none";

        // Update step status
        updateStepStatus("step-processImage", "processing", "PROCESSING");

        try {
          // Create new AbortController for this request
          currentController = new AbortController();
          const signal = currentController.signal;

          const response = await fetch(`${apiUrl}/process-image`, {
            method: "POST",
            body: formData,
            signal: signal,
          });

          if (!response.ok) {
            throw new Error(`Server responded with status: ${response.status}`);
          }

          const result = await response.json();

          if (result.session_id) {
            // Save session ID for subsequent steps
            currentSessionId = result.session_id;

            // Update step status and content
            updateStepStatus("step-processImage", "completed", "COMPLETED");
            setStepContent(
              "step-processImage",
              result.problem_analysis ||
                "Problem analysis completed successfully.",
              "text"
            );

            // Store data in our state
            stepsState.processImage.data = result;
          } else {
            throw new Error(result.error || "Unknown error occurred");
          }
        } catch (error) {
          // Don't retry if the request was cancelled
          if (error.name === "AbortError") {
            return;
          }

          if (stepsState.processImage.retryCount < retryConfig.maxRetries) {
            // Increment retry count
            stepsState.processImage.retryCount++;

            // Update status with retry attempt
            updateStepStatus(
              "step-processImage",
              "processing",
              `RETRYING (${stepsState.processImage.retryCount}/${retryConfig.maxRetries})`
            );

            // Show retry message
            setStepContent(
              "step-processImage",
              `Error encountered: ${error.message}\nRetrying in ${
                retryConfig.retryDelay / 1000
              } seconds... (Attempt ${stepsState.processImage.retryCount}/${
                retryConfig.maxRetries
              })`,
              "text"
            );

            // Retry after delay
            setTimeout(() => processImage(), retryConfig.retryDelay);
          } else {
            // Max retries reached, show error
            updateStepStatus("step-processImage", "error", "ERROR");
            setStepContent(
              "step-processImage",
              `Error: ${error.message}\nMax retry attempts (${retryConfig.maxRetries}) reached.`,
              "text"
            );

            // submitButton.style.display = "inline-block";
            // changeImageButton.style.display = "inline-block";
          }
        }
      }

      // Step 2: Generate Script
      async function generateScript() {
        if (!currentSessionId) {
          console.error("No session ID available");
          return;
        }

        // Update step status
        updateStepStatus("step-generateScript", "processing", "PROCESSING");

        try {
          // Create new AbortController for this request
          currentController = new AbortController();
          const signal = currentController.signal;

          const response = await fetch(`${apiUrl}/generate-script`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              session_id: currentSessionId,
            }),
            signal: signal,
          });

          if (!response.ok) {
            throw new Error(`Server responded with status: ${response.status}`);
          }

          const result = await response.json();

          if (result.script_text) {
            // Update step status and content
            updateStepStatus("step-generateScript", "completed", "COMPLETED");
            setStepContent("step-generateScript", result.script_text, "text");

            // Store data in our state
            stepsState.generateScript.data = result;
          } else {
            throw new Error(result.error || "Failed to generate script");
          }
        } catch (error) {
          // Don't retry if the request was cancelled
          if (error.name === "AbortError") {
            return;
          }

          if (stepsState.generateScript.retryCount < retryConfig.maxRetries) {
            // Increment retry count
            stepsState.generateScript.retryCount++;

            // Update status with retry attempt
            updateStepStatus(
              "step-generateScript",
              "processing",
              `RETRYING (${stepsState.generateScript.retryCount}/${retryConfig.maxRetries})`
            );

            // Show retry message
            setStepContent(
              "step-generateScript",
              `Error encountered: ${error.message}\nRetrying in ${
                retryConfig.retryDelay / 1000
              } seconds... (Attempt ${stepsState.generateScript.retryCount}/${
                retryConfig.maxRetries
              })`,
              "text"
            );

            // Retry after delay
            setTimeout(() => generateScript(), retryConfig.retryDelay);
          } else {
            // Max retries reached, show error
            updateStepStatus("step-generateScript", "error", "ERROR");
            setStepContent(
              "step-generateScript",
              `Error: ${error.message}\nMax retry attempts (${retryConfig.maxRetries}) reached.`,
              "text"
            );
          }
        }
      }

      // Step 3: Generate Video
      async function generateVideo() {
        if (!currentSessionId) {
          console.error("No session ID available");
          return;
        }

        // Update step status
        updateStepStatus("step-generateVideo", "processing", "PROCESSING");

        try {
          // Create new AbortController for this request
          currentController = new AbortController();
          const signal = currentController.signal;

          const response = await fetch(`${apiUrl}/generate-video`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              session_id: currentSessionId,
              video_quality: "medium",
            }),
            signal: signal,
          });

          if (!response.ok) {
            throw new Error(`Server responded with status: ${response.status}`);
          }

          const result = await response.json();

          if (result.video_url) {
            // Update step status and content
            updateStepStatus("step-generateVideo", "completed", "COMPLETED");
            setStepContent("step-generateVideo", result.video_url, "video");

            // Store data in our state
            stepsState.generateVideo.data = result;
          } else {
            throw new Error(result.error || "Failed to generate video");
          }
        } catch (error) {
          // Don't retry if the request was cancelled
          if (error.name === "AbortError") {
            return;
          }

          if (stepsState.generateVideo.retryCount < retryConfig.maxRetries) {
            // Increment retry count
            stepsState.generateVideo.retryCount++;

            // Update status with retry attempt
            updateStepStatus(
              "step-generateVideo",
              "processing",
              `RETRYING (${stepsState.generateVideo.retryCount}/${retryConfig.maxRetries})`
            );

            // Show retry message
            setStepContent(
              "step-generateVideo",
              `Error encountered: ${error.message}\nRetrying in ${
                retryConfig.retryDelay / 1000
              } seconds... (Attempt ${stepsState.generateVideo.retryCount}/${
                retryConfig.maxRetries
              })`,
              "text"
            );

            // Retry after delay
            setTimeout(() => generateVideo(), retryConfig.retryDelay);
          } else {
            // Max retries reached, show error
            updateStepStatus("step-generateVideo", "error", "ERROR");
            setStepContent(
              "step-generateVideo",
              `Error: ${error.message}\nMax retry attempts (${retryConfig.maxRetries}) reached.`,
              "text"
            );
          }
        }
      }

      // Step 4: Improve Video
      async function improveVideo() {
        if (!currentSessionId) {
          console.error("No session ID available");
          return;
        }

        // Update step status
        updateStepStatus("step-improveVideo", "processing", "PROCESSING");

        try {
          // Create new AbortController for this request
          currentController = new AbortController();
          const signal = currentController.signal;

          const response = await fetch(`${apiUrl}/improve-video`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              session_id: currentSessionId,
              video_quality: "medium", // Default to medium quality
            }),
            signal: signal,
          });

          if (!response.ok) {
            throw new Error(`Server responded with status: ${response.status}`);
          }

          const result = await response.json();

          if (result.improved_video_url || result.video_url) {
            // Update step status and content
            updateStepStatus("step-improveVideo", "completed", "COMPLETED");

            let videoHtml = `
              <div class="video-container">
                <video class="video-player" controls autoplay>
                  <source src="${
                    result.improved_video_url || result.video_url
                  }" type="video/mp4">
                  Your browser does not support the video tag.
                </video>
                <p><a href="${
                  result.improved_video_url || result.video_url
                }" target="_blank">Open video in new tab</a></p>
              </div>
            `;

            setStepContent("step-improveVideo", videoHtml, "html");

            // Store data in our state
            stepsState.improveVideo.data = result;
          } else {
            throw new Error(result.error || "Failed to improve video");
          }
        } catch (error) {
          // Don't retry if the request was cancelled
          if (error.name === "AbortError") {
            return;
          }

          if (stepsState.improveVideo.retryCount < retryConfig.maxRetries) {
            // Increment retry count
            stepsState.improveVideo.retryCount++;

            // Update status with retry attempt
            updateStepStatus(
              "step-improveVideo",
              "processing",
              `RETRYING (${stepsState.improveVideo.retryCount}/${retryConfig.maxRetries})`
            );

            // Show retry message
            setStepContent(
              "step-improveVideo",
              `Error encountered: ${error.message}\nRetrying in ${
                retryConfig.retryDelay / 1000
              } seconds... (Attempt ${stepsState.improveVideo.retryCount}/${
                retryConfig.maxRetries
              })`,
              "text"
            );

            // Retry after delay
            setTimeout(() => improveVideo(), retryConfig.retryDelay);
          } else {
            // Max retries reached, show error
            updateStepStatus("step-improveVideo", "error", "ERROR");
            setStepContent(
              "step-improveVideo",
              `Error: ${error.message}\nMax retry attempts (${retryConfig.maxRetries}) reached.`,
              "text"
            );
          }
        }
      }

      // Set up drag and drop functionality
      document.addEventListener("DOMContentLoaded", function () {
        const dropZone = document.querySelector(".file-upload-label");
        const fileInput = document.getElementById("imageInput");

        ["dragover", "dragenter"].forEach((eventName) => {
          dropZone.addEventListener(
            eventName,
            function (e) {
              e.preventDefault();
              e.stopPropagation();
              this.style.borderColor = "#007bff";
              this.style.backgroundColor = "#f0f7ff";
            },
            false
          );
        });

        ["dragleave", "dragend"].forEach((eventName) => {
          dropZone.addEventListener(
            eventName,
            function (e) {
              e.preventDefault();
              e.stopPropagation();
              this.style.borderColor = "#ccc";
              this.style.backgroundColor = "#f8f8f8";
            },
            false
          );
        });

        dropZone.addEventListener(
          "drop",
          function (e) {
            e.preventDefault();
            e.stopPropagation();
            this.style.borderColor = "#ccc";
            this.style.backgroundColor = "#f8f8f8";

            const dt = e.dataTransfer;
            if (dt.files.length) {
              fileInput.files = dt.files;
              // Trigger the change event manually
              const event = new Event("change");
              fileInput.dispatchEvent(event);
            }
          },
          false
        );

        // Add change event listener to the file input
        fileInput.addEventListener("change", handleImageSelection);
      });
    </script>
  </head>
  <body>
    <div id="container">
      <h1>Math to Animation</h1>
      <p>
        Upload an image of a math problem to generate a step-by-step educational
        animation explaining it, inspired by the visualization style of
        <a href="https://www.youtube.com/@3Blue1Brown">3Blue1Brown</a>, using
        the <a href="https://github.com/3b1b/manim">Manim library</a>.
      </p>
      <form id="imageForm" onsubmit="processImage(event)">
        <div class="file-upload">
          <label for="imageInput" class="file-upload-label">
            <span class="file-upload-label-text">
              <span class="file-upload-icon">🖼️</span>
              Click to select an image or drag & drop
            </span>
          </label>
          <input
            type="file"
            id="imageInput"
            name="image"
            class="file-upload-input"
            accept="image/*"
            required
          />
          <div class="image-preview-container" id="imagePreviewContainer">
            <img
              src="#"
              alt="Preview"
              class="image-preview"
              id="imagePreview"
            />
          </div>
        </div>
        <button type="submit" class="submit-button">Upload Image</button>
      </form>

      <!-- Process Steps Container -->
      <div class="process-steps">
        <!-- Step 1: Process Image -->
        <div id="step-processImage" class="step pending">
          <div class="step-header">
            <div class="step-title">Step 1: Process image</div>
            <div class="step-status pending">PENDING</div>
            <div class="step-spinner"></div>
          </div>
          <div id="step-processImage-timer" class="step-timer"></div>
          <div id="step-processImage-content" class="step-content"></div>
          <div class="step-buttons">
            <button
              onclick="handleCancel('processImage')"
              class="cancel-button"
              style="display: none"
            >
              Cancel
            </button>
            <button
              onclick="tryAgainFromStep('processImage')"
              class="try-again-button"
              style="display: none"
            >
              Try Again
            </button>
          </div>
        </div>

        <!-- Step 2: Generate Script -->
        <div id="step-generateScript" class="step pending">
          <div class="step-header">
            <div class="step-title">Step 2: Generate script</div>
            <div class="step-status pending">PENDING</div>
            <div class="step-spinner"></div>
          </div>
          <div id="step-generateScript-timer" class="step-timer"></div>
          <div id="step-generateScript-content" class="step-content"></div>
          <div class="step-buttons">
            <button
              onclick="handleCancel('generateScript')"
              class="cancel-button"
              style="display: none"
            >
              Cancel
            </button>
            <button
              onclick="tryAgainFromStep('generateScript')"
              class="try-again-button"
              style="display: none"
            >
              Try Again
            </button>
          </div>
        </div>

        <!-- Step 3: Generate Visual Elements -->
        <div id="step-generateVisuals" class="step pending">
          <div class="step-header">
            <div class="step-title">Step 3: Generate visual elements</div>
            <div class="step-status pending">PENDING</div>
            <div class="step-spinner"></div>
          </div>
          <div id="step-generateVisuals-timer" class="step-timer"></div>
          <div id="step-generateVisuals-content" class="step-content"></div>
          <div class="step-buttons">
            <button
              onclick="handleCancel('generateVisuals')"
              class="cancel-button"
              style="display: none"
            >
              Cancel
            </button>
            <button
              onclick="tryAgainFromStep('generateVisuals')"
              class="try-again-button"
              style="display: none"
            >
              Try Again
            </button>
          </div>
        </div>

        <!-- Step 4: Generate Video -->
        <div id="step-generateVideo" class="step pending">
          <div class="step-header">
            <div class="step-title">Step 4: Generate video</div>
            <div class="step-status pending">PENDING</div>
            <div class="step-spinner"></div>
          </div>
          <div id="step-generateVideo-timer" class="step-timer"></div>
          <div id="step-generateVideo-content" class="step-content"></div>
          <div class="step-buttons">
            <button
              onclick="handleCancel('generateVideo')"
              class="cancel-button"
              style="display: none"
            >
              Cancel
            </button>
            <button
              onclick="tryAgainFromStep('generateVideo')"
              class="try-again-button"
              style="display: none"
            >
              Try Again
            </button>
          </div>
        </div>

        <!-- Step 5: Improve Video -->
        <div id="step-improveVideo" class="step pending">
          <div class="step-header">
            <div class="step-title">Step 5: Review and Improve video</div>
            <div class="step-status pending">PENDING</div>
            <div class="step-spinner"></div>
          </div>
          <div id="step-improveVideo-timer" class="step-timer"></div>
          <div id="step-improveVideo-content" class="step-content"></div>
          <div class="step-buttons">
            <button
              onclick="handleCancel('improveVideo')"
              class="cancel-button"
              style="display: none"
            >
              Cancel
            </button>
            <button
              onclick="tryAgainFromStep('improveVideo')"
              class="try-again-button"
              style="display: none"
            >
              Try Again
            </button>
          </div>
        </div>
      </div>
    </div>
    <div class="footer">
      made with ❤️ by <a href="https://x.com/max_brillant">Max Brillant</a>
      <a
        class="github-link"
        href="https://github.com/MaxBrillant/image-to-manim"
        target="_blank"
      >
        <i class="fab fa-github"></i>
        GitHub
      </a>
    </div>
  </body>
</html>
